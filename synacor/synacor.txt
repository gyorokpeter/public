Here is my detailed experience of the Synacor challenge.

The goal is to collect 8 different codes that can then be submitted on the challenge website. They range from very easy to very hard and I will list the way to get each of them below.
The initial task is to implement a virtual machine according to the included specification. The part that's a bit strange is how the registers are encoded in the binary. Each memory location can hold a 15-bit number but the encoding of the registers requires values outside of this range. Furthermore the code does need to be able to self-modify. So there will be some memory addresses that are in a "metastable" state - they have values in them that cannot be written by the code. The program helpfully introduces the opcodes one by one and does some basic checks on them to ensure they work, giving error messages if they don't. I already implemented my VM from the start in a way that throws an exception if it runs into an unknown instruction, so seeing this exception rather than an error and halt was a good sign every time. At the end of the self-check there is some time-consuming operation - it turns out that this decrypts the data from its original scrambled format, which makes sure you can't see what the challenge is really about until you actually have a working VM. However at that point there was still one bit missing, which was the input instruction. It is not introduced until after the self-test is done.
The reason for this is that it turns out the "payload" of the challenge is a text-based adventure game, and it only starts asking for input after entering the main game loop where it prints the current location info and asks for what you want to do. Since I'm programming in q, it is much easier to model the VM as something you need a function call to get into, rather than hardwiring it to stdin/stdout as you might do in C++ or Java. While this meant I had to interact with the game by wrapping every command in double quotes and prefixing them with the function name (I called it just "r" so it was short), it allowed for more flexible experimentation by not being stuck in the game loop - it would just give back control to the REPL whenever an input instruction was attempted with nothing in the input queue. By putting my commands into KDB Studio I could simply copy/paste them and make solution sequences.
The game is interesting on its own but just reaching this stage doesn't mean I could leave my code alone. Eventually there are a few challenges that require some coding to solve, including "reality warping" by poking into the VM state and some reverse engineering. The first part is just exploration of a cave and some item collection. Then I arrived at the first puzzle which consists of an equation with 5 blank spaces for numbers, with the available numbers provided by coins that can be picked up. To find the solution I made a function that tries every permutation - see .synsolve.coinPuzzle in synacorSolution.q.
After inputting the correct solution, I found a teleporter. It took me to the self-referential Synacor Headquarters, where there was a strange book explaining my next task in a very amusing way, by involving the registers and the game program in its narrative. The "confirmation process" takes a number (I called it "p") and evaluates f(4,1) where:
    f(x,y) = y+1 if x=0
             f(x-1,p) if x>0 and y=0
             f(x-1, f(x,y-1)) if x>0 and y>0
which is nearly the same as the Ackermann function but the second case replaces 1 with "p" and arithmetic is modulo 32768. I had to find the value for p that results in f(4,1)=6. The game obviously uses the inefficient recursive implementation. Unfortunately q is not very helpful here because this kind of calculation cannot be vectorized as it contains either recursive calls (inefficient and may hit the stack limit) or cross-referencing memory addresses that successively depend on each other, with the addition of the modulo arithmetic. This combination is a very weak point in q. I chose to implement the function as follows: considering that there can be only 32768 possible values for y, I precalculate f(0,y) for all y, which is til[32768] rotated by 1. Then I also precalculate f(1,y) which is til[32768] rotated by p+1. Then the same for f(2,y) which still has a closed formula. But for f(3,y) I can only use an iterative solution as every element relies on the previous one. The same would be true for f(4,y) but I only need the first two elements. Now this whole calculation is quite fast when run for a single number, but I had to run it for 32768 possible numbers so it quickly adds up. After over 5 minutes it spits out the correct solution. See .synsolve.teleporterPuzzle in synacorSolution.q.
My input handling behavior also comes handy in the "reality warp" for the teleporter puzzle - while you can pre-initialize the VM to use the alternate warp, in order to display all 7 in-VM codes in a single run you need to first use the teleporter in the default state and then do the reality warp and use it again.
With the hacked teleporter I ended up in a new location and the final puzzle. it is a 4*4 grid with either a number or an operator (+,-,*) on it. I had to find a path through the grid that starts at the bottom left, ends at the bottom right and produces a certain value after applying the operations. BFS seems like the best way to find the solution. Although once again q does not excel at this kind of iterative algorithm, at least this time it can be vectorized by processing the entire queue on each iteration, rather than just taking the first element. I enjoyed the fact that the vault can be encoded by directly putting the operators themselves into the cells of a matrix next to the numbers. The vector BFS finds the solution in about 20 seconds. With this solution I could reach the final room and complete the challenge.
As I explored the game, like a good Zork player, I made a map. It is mostly complete, although minor discrepancies remain. It is included in the repo as map.png.

Here are how to get the 8 codes:
1. Included in the arch-spec file.
2. Printed early on - it is enough to implement the NOP and OUT instructions to get it.
3. Printed after the self-check. This requires implementing all instructions except IN.
4. Tablet code: given for using the tablet, which is right at the starting point.
5. Maze code: found on the walls while exploring the cave in the first part.
6. Teleporter code: seen during the original teleport sequence after the coin puzzle.
7. Hacked teleporter code: seen during the modified teleport sequence.
8. Vault code: seen by looking in the mirror.

My experience with these codes:
I actually didn't get them in this order. I missed the tablet code because I didn't realize that simply "use tablet" would result in getting it. I was expecting the table to be part of a later puzzle and that I would have to figure out what to write on the tablet. Only after I reached the final room and I still had a few codes missing, I realized that I didn't use the tablet so far so I tried and bam, there is one of the missing codes. Something similar happened to the maze code, I didn't pay attention to the message that was printed between two turns, so I missed it initially. I did come across it eventually somehow. And finally on the vault code, I failed miserably by not realizing that since I'm looking at the code in a mirror, it needs to be mirrored. I reverse engineered the whole code generation process, the result of which is the "keygen" that can be seen in synacorKeyGen.cpp. Only after taking a hint I realized that there is a separate alphabet for the vault code because it needs to consist of only mirrorable characters (which are either symmetrical, like wuiolxv8WTYUIOAHXVM, or b<->d and p<->q).

Finally, while I originally solved the challenge in 2015, my solution got a revamp after the 2019 season of Advent of Code, which inspired me to create GenArch. So I refactored the interpreter and added the necessary APIs, and also cleaned up my code so it can be put in this repo. However as I was already done with all the reverse engineering by the time I did this, I didn't feel like optimizing the performance of GenArch to handle programs of this size.
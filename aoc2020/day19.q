gen:{[r0;rule]
    if[0=count rule; :enlist ""];
    m:r0[first rule];
    $[m`t;raze m[`r],/:\:gen[r0;1_rule];
        raze gen[r0] each (m[`r],\:1_rule)]};
d19:{p:"\n\n"vs x;
    r0:1!{([]num:"J"$x[;0];t:"\""in/:x[;1];r:value each/:" | "vs/:x[;1])}": "vs/:"\n"vs p[0];
    str:"\n"vs p 1;
    };
d19p1:{
    p:d19 x;r0:p 0;str:p 1;
    found:gen[r0;enlist 0];
    sum str in found};
d19p2:{
    p:d19 x;r0:p 0;str:p 1;
    found42:gen[r0;enlist 42];
    found31:gen[r0;enlist 31];
    if[(0<count found42 inter found31); '"unsupported input"];
    if[1<count distinct count each found42,found31; '"unsupported input"];
    bits:count[found42 0] cut/:str;
    pre0:{x:deltas x;$[0=first x;0;x?-1]}each bits in found42;
    post0:{x:deltas reverse x;$[0=first x;0;x?-1]}each bits in found31;
    sum(0<post0) and (pre0>post0) and (pre0+post0)=count each bits};

/
d19p1 x:"0: 4 1 5\n1: 2 3 | 3 2\n2: 4 4 | 5 5\n3: 4 5 | 5 4\n4: \"a\"\n5: \"b\"\n\nababbb\nbababa\nabbbab\naaabbb\naaaabbb"

OVERVIEW:

We use a recursive generation function to generate all the possible strings from a rule. This is
very slow for part 1. Its usage in part 2 is much quciker, and in fact that insight could be used
to improve part 1 but then it would no longer work on the example input for part 1 which I want to
avoid.

PART 1:
We generate all the possible strings from rule 0 and then check how many of the given strings are
in the generated ones.

PART 2:
We generate the sets for rules 42 and 31, which is much quicker. The next part heavily depends on
some assumptions on the input. The rules must generate strings of the same length, there must be
no overlap between the sets generated by the two rules, and the input strings must be of lengths
that are multiples of the generated strings. With this in mind we find all prefixes that match
those generated by rule 42, and all suffixes that match those generated by rule 31. We count how
many such matches there are. For a string to be valid, at least one suffix must match, the
number of prefixes that match must be greater than the number of suffixes, and there must be no
chunk that doesn't match either a prefix or a suffix (or e.g. a prefix appearing after a suffix).
These conditions can be quickly checked from the match counts.
